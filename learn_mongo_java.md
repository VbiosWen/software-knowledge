## Learn about Mongo. :smile:

- ## [Introduction](#1)
  - ### [Rich data types](#1_1)
  - ### [Easily Extendable](#1_2)
  - ### [Rich functionalities](#1_3)
  - ### [Without sacrificing speed](#1_4)
  - ### [Simple management](#1_5)
  - ### [Other content](#1_6)
- ## [Elementary](#2)
  - ### [Document](#2_1)
  - ### [Collection](#2_2)
  - ### [Database](#2_3)
  - ### [Start up MongoDB](#2_4)
  - ### [MongoDB Shell](#2_5)
  - ### [Data Type](#2_6)
- ## [Insert,Update and Delete document](#3)
  - ### [Insert and save Document](#3_1)
  - ### [Delete Document](#3_2)
  - ### [Update Document](#3_3)
  - ### [Instant Completion](#3_4)
  - ### [Request and Connection](#3_5)

## mongoDB is a document database.I want to tell you what I know. :smile: give me :star:,thanks.

:smile: :bird: :love_hotel: :house: :hammer:

- ## <p id="1">简介</p>
  mongodb 是一种强大,灵活,可扩展的数据存储方式.它扩展了关系型数据库众多有用的功能,如辅助索引,范围查询和排序.mongodb 的功能非常丰富,内置 mapreduce 式聚合支持.,以及对地理空间索引的支持.
  - ### <p id="1_1">丰富的数据类型</p>
    mongodb 是一种文档型数据库,所以对数据类型支持非常丰富,不需要像 MySQL 一样事先定义好数据类型,MongoDB 会根据传入数据自动分配类型.基于文档模式,MongoDB 一个文档就可以表示复杂的数据关系.(_文档就相当于 MySQL 数据库中的行_).
  - ### <p id="1_2">更优秀的扩展方式</p>
    MongoDB 在设计之初就考虑到了数据库的扩展性,它所采用的面向文档的数据模型可以使其自动在多台服务器之间分割数据,它还可以平衡集群的数据和负载,自动重排文档.可以让开发者更好的关注业务层面,而无需在数据库设计上花费更多的时间.
  - ### <p id="1_3">丰富的功能</p>
    - 1. **索引**
         _MongoDB 不仅支持通用辅助索引,能进行多种快速查询,也提供唯一索引,复合索引和地理空间数据的索引能力._
    - 2. **存储 JavaScript**
         _开发人员不必使用 存储过程了,可以直接在服务端存取 JavaScript 的函数和值._
    - 3. **聚合**
         _MongoDB 支持 MapReduce 和其他聚合工具_
    - 4. **固定集合**
         _集合的大小是有上限的,对于某些日志数据特别有用_
    - 5. **文件存储**
         _MongoDB 支持一种容易使用的协议存储大型文件和元数据._
  - ### <p id="1_4">不牺牲速度</p>
    MongoDB 在设计之初就以速度为目的,所以在设计时牺牲了很多关系型数据库的特性.同时 MongoDB 采用 MongoDB 协议作为服务器的交互方式,比同类型的 http or rest 更少的开销.同时 MongoDB 支持对对文档进行动态填充,预分配数据文件,用空间换取性能的稳定.默认的存储引擎中使用了内存映射文件,将内存管理工作交给操作系统去处理.动态查询优化器会记住'最高效'的查询方式.总之,MongoDB 尽可能在各个方面提高性能.
  - ### <p id="1_5">简单的管理</p>
    MongoDB 尽量让服务器自治来简化数据库的管理.除了启动数据库之外,MongoDB,几乎没有必要的管理操作.MongoDB 尽可能的满足各种异常场景的自修复.
  - ### <p id="1_6">其他内容</p>
    继续看就知道啦 :love_hotel:
- ## <p id="2">入门</p>
  - 文档是 MongoDB 中的数据单元,类似于关系型数据库中的行(_但比行要复杂的多_).
  - 集合可以看做是没有模式的表.
  - MongoDB 单个实例可以容纳多个独立的数据库,每一个都有自己的集合和权限.
  - MongoDB 自带简洁而功能强大的的 JavaScript shell,对于 MongoDB 的管理和操作非常强大.
  - MongoDB 每个文档中都包含一个特殊的键 \_id,它在文档所处的集合中唯一.
  - ### <p id="2_1">文档</p>
    文档是 MongoDB 中的核心概念.多个键及其关联的值有序地放置在一起便是文档.例子
    ```json
    {"_id":ObjectId(""5a6a1d787c00f2a8e85f7a18"),"cid":NumberLong(50008898)}
    ```
    - 1. 文档中的键/值对是有序的,文档中的值不仅可以是字符串(_Default utf-8_),还可以是其他几种数据类型.文档中的键均是字符串.
  - ### <p id="2_2">集合</p>
    - 1. **无模式** 集合就是一组文档.类似于关系型数据库中的表.(_集合可以放置任何文档_),But,建议将同类型的集合放置在一个集合中,这样既容易分辨,又能有好的查询效率.
    - 2. **命名**
      1. 集合名不能是空字符串"".
      1. 集合名不能含有\0 字符(空字符),这个字符表示集合名的结尾.
      1. 集合名不能以"system."开头,这是系统保留前缀.
      1. 用户创建的集合名字不能含有保留字符\$.
         > 任何的骚操作建议都不要用,老老实实写个正常的名字吧.:alien:
  - ### <p id="2_3">数据库</p>
    MongoDB 中多个文档组成集合,集合组成数据库.一个 MongoDB 实例可以承载多个数据库,每个数据库都有独立的权限控制,即便在磁盘上,不同的数据库也放置在不同的文件中.建议将一个应用的所有数据都存储在一个数据库中.
    > 数据库名也不要有骚操作.不然真出问题了,你就炸了.:imp:
    > MongoDB 自带数据库:
    - **admin**
      从权限的角度看,这是"root"数据库.在这个数据库中,可以进行用户的添加删除,权限控制.
    - **local**
      这个数据库永远不会被复制,可以用来存储限于本地单台服务器的任意集合.
    - **config**
      当 MongoDB 用于分片设置时,config 在数据库内部使用,用于保存分片的相关信息.
  - ### <p id="2_4">启动 MongoDB</p>
    ```shell
    $ ./mongod 启动 MongoDB,使用默认数据目录,端口号.
    ```
  - ### <p id="2_5">MongoDB shell</p>
    MongoDB 自带一个 JavaScript shell,可以从命令行与 MongoDB 实例交互.这个 shell 非常有用,通过它可以执行管理操作,检查运行实例.
  ```mongo
  ./mongo --运行 mongo client
  > x=200
  > x/5;
  40
  > Math.sin(Math.PI/2) --调用 JavaScript 的库.
  > new Date("2010/1/1")
  > function factorial(n){
    if(n <= 1 ) return 1;
    return n * factorial(n-1);
  }
  > factorial(5) --定义 JavaScript 函数,并调用.
  ```
- ### <p id="2_6">数据类型</p>
  - 1. **基本数据类型**
       MongoDB 的文档类似于 json,在概念上和 JavaScript 中的对象神似.MongoDB 在保留 json 基本的键值对特性的基础上,添加了其他一些数据类型.
    - 1.  null 用于表示空值或者不存在的字段.
    - 2.  布尔 布尔类型有 true 和 false.
    - 3.  32 位整数.
    - 4.  64 位整数.
    - 5.  64 位浮点数
    - 6.  字符串
    - 7.  符号
    - 8.  对象 id
    - 10. 日期
    - 11. 正则表达式
    - 12. 代码
    - 13. 二进制数据
    - 14. 最大值
    - 15. 最小值
    - 16. 未定义
    - 17. 数组
    - 18. 内嵌文档
  - 2. **数字** JavaScript 只支持一种数字类型,但是 MongoDB 支持 3 中,所以建议不要再 MongoDB 自带的 shell 中使用这些东西.
  - 3. **日期** 在 JavaScript 中,Date 对象用作 MongoDB 的日期类型.
  - 4. **数组** 数组是一组值,既可以作为有序对象,也可以作为无序对象.数组是一种无模式的数组,可以存储 string,integer 等类型的数据.
  - 5. **内嵌文档** 内嵌文档就是把整个 MongoDB 文档作为另一个文档中键的一个值.这样数据可以组织得更自然些.
  - 6. **\_id and ObjectId** MongoDB 的文档中必须包含一个\_id 的键,键值可以是任意类型的数据,如果没有指定,就是一个 ObjectId 对象.
    - 1. ObjectId ObjectId 是\_id 的默认类型,因为 MongoDB 在设计之初就是为了支持分布式数据库的,自增 ID 在分布式数据库中还是有很大的问题的,所以 ObjectId 的概念应运而生.
         ObjectId 使用 12 个字节的存储空间,每个字节每位 16 进制数字,是一个 24 位的字符串. ObjectId 生成方式
         0|1|2|3|4|5|6|7|8|9|10|11
         时间戳 |机器 | pid|计数器
         前 4 个字节是从标准纪元开始的时间戳,单位为 秒.
      - 1. 时间戳,与随后的 5 个字节组合起来,提供了秒级别的唯一性.
      - 2. 这 4 个字节隐含了文档创建的时间.可以用来获取创建时间 :tea:.
           接下来的 3 字节是所在主机的唯一标识符.通常是主机名的散列值,主要为了确保不同主机生成不同的 ObjectID,
      - 3. pid 表示产生 ObjectId 的进程标识符(PID)
      - 4. 后 3 个字节就是自增的计数器.确保相同进程同一秒产生的 ObjectId 是不一样的,每一秒钟最多允许每个进程拥有 256^3(_16777216_)个不同的 ObjectId.
    - 2. 自动生成\_id
      - 1. 让 MongoDB 服务端生成 \_id 这个事情,是会产生开销的.尽量让客户端生成.
      - 2. 在客户端生成 ObjectId,可以有更多方便的操作.比如说可以直接拿到插入数据的 id,如果让 MongoDB server 生成 id,就需要再执行一次查询才能拿到 \_id.
- ## <p id="3">创建,更新及删除文档</p>

  - ### <p id="3_1">插入并保存文档</p>
    `db.foo.insert({"bar":"baz"})`
    - **批量插入**
      如果要插入多个文档,批量插入是最快的.一次批量插入只是单个 TCP 请求,避免了许多零碎的请求带来的开销.由于无需处理大量的消息头,这样就能够减少插入时间. 单个文档发送到数据库时,会带一个头部信息,告诉数据库要进行什么操作,批量插入时只需要带一个头部信息就可以了,不用一遍又一遍地处理每一个文档的这种信息了.
      > 当前版本的 MongoDB 支持的最大消息长度是 16 MB.
    - **插入:原理和作用**
      当数据库执行插入时,先将数据序列化成 BSON 形式,然后将其送入数据库.数据库解析 BSON,检验是否包含\_id 键,并且文档不超过 16 MB.除此之外,不做别的数据验证,就只是简单地将文档原样存入数据库中.这样避免了传统的注入式攻击.
  - ### <p id="3_2">删除文档</p>

  ```sql
  db.users.remove() -- 删除 users 集合中所有的文档.但不会删除集合本身.原有的索引也会保留.
  db.users.remove({"_id":ObjectId("id")}) -- remove 可以接受一个查询条件
  ```

  - **删除速度**
    删除文档通常会很快,但是要清除整个集合,直接删除集合(_然后重建索引_)会更快.
  - ### <p id="3_3">更新文档</p>

    文档存入数据库以后,就可以用 update 方法来修改它.update 有两个参数,一个是查询文档,用来找出要更新的文档,另一个是修改器(modifier)文档,描述对找出的文档做哪些更改.更新操作是原子的,若是两个更新同时发生,FIFO 执行.

    - **文档替换**
      更新最简单的情形就是完全用一个新文档代替匹配的文档.这适用于模式结构发生较大变化的时候,不介绍,建议在应用层适用.
    - **使用修改器**
      通常文档只会有一部分更新.利用原子的更新修改器,可以使得这种部分更新极为高效.

      ```sql
      db.users.update({query},{"$set":{"userName":"哇咔咔"}) -- 将查询出来的数据的 userName 都改为哇咔咔.
      db.users.update({query},{"$unset":{"userSex":1}}) --删除这个键,当然 value 也被删了.
      db.users.update({query},{"$inc":{"score":50}}) -- 跟查询到的 user 的分数加 50,清华北大不是梦. 只能作用于 number 类型.
      db.users.update({query},{"$push":{"userCard":"ICBC"}}) -- 为用户添加一个银行卡.定个小目标,日赚一个亿 哇咔咔.
      db.users.update({"money":{"$ne":"0"}},{"$push":{"money":"50000000000000000"}) -- 如果你的钱在库中为 0,你可以用这种方式把它加进去,而且是数组哦.
      db.users.update({query},{"$addToSet":{"cardId":{"4232422424442442424"}}}) -- 如果你忘记了你的卡号是不是已经被保存在库中了,可以用这种方式将卡号再放进去一次,如果存在就不做任何操作,如果不存在就加一个卡号.真土豪,自己几张卡都记不清了.
      db.users.update({query},{"$addToSet":{"cardId":{"$each":["cardId1","cardId2"]}}}) -- 如果你忘记的卡太多,就一次性这样玩吧.每一个不存在库中的卡号都能被添加哦.
      db.users.update({query},{"cardId":{"$pop":{key:1}}})
      -- 删除一个卡号,最近消费有点高啊,竟然把卡都刷废了.
      db.users.update({query},{"$pull",{"cardId":1})
      -- 删除匹配项,会将所有的匹配到的数据删除掉.
      db.users.update({query},{"$inc":{"userInfo.0.money":1}})-- 数据数据里面包含 json,先找到数据的数组下标,然后找到对应字段,进行原子+1
      db.users.update({query},{"$inc":{"cardMoney":20}},true) --upsert 懂了吗?
      db.users.update({query},{$set:{"gift":"Happy birthday"}},false,true) false 代表不是 upsert,不用插入文档,true 代表查到的都更新
      db.users.save({bson}) --save 是一个 shell 函数,可以在文档不存在时插入,存在时更新.它只有一个参数(文档),if document contain _id, it will be upserted,else it will be insert.
      db.update({"_id":"ObjectId()"},x) --if you don`t want to use save method, you can do same thine by it.
      db.update({query},{$set:{column:value}},false,true) -- By default,The update operation updates only the first document found. --默认情况下,更新操作只会更新查找到的第一个文档,可以在 update 方法中第四个值传 true 来更新多个文档.

      ```

    - **修改器速度**
      有的修改器运行速度很快,例如 \$inc,因为不需要改变文档的大小,但是数组修改器更改了文档的大小,就会慢一些(_\$set 能在文档大小不发生改变时立即修改,否则性能会有所下降._).
      MongoDB 预留了一些补白给文档,来适应大小变化(_事实上,系统会根据文档通常的大小变化情况来相应的调整补白的大小._),但是要是超出了原来的预留空间,最后还是要分配新的空间.空间分配会减慢速度,也会随着数组变长,MongoDB 也会因为需要更长的时间遍历,对每个数组的修改也会慢下来.

  - ### <p id="3_4">瞬间完成</p>
    上面讨论的插入更新删除操作都是瞬间完成的,也就是说客户端只管提交,不管返回结果.这样就导致我们无法知道数据是否被成功操作.(_离弦之箭_),这个特点的优点很明显,速度快,这些操作都会非常快地执行,它只会受客户端发送的速度和网络速度的制约.如果出现服务器崩溃等异常情况,客户端还是会发送写操作到服务器的,完全不理会到底有没有服务器.
    安全的代价就是性能,即便忽略了客户端处理异常的开销(_不同语言的开销不一样,但一般都不是轻量级的_),等待数据库响应本身的时间比只发送消息的时间多一个数量级.所以,应用程序需要权衡数据的重要性(_以及丢失后的后果_)及速度需求.
    - 如果不考虑安全性的话,就采用离弦之箭的方式,使用场景(_日志等对数据完整性有要求的方面_).
    - 想要活的稍长一点,就把重要的数据(账号,信用卡号,电子邮件)用安全的方式操作,其余的数据就是采用离弦之箭的方式.
    - 安全操作不仅能应付世界末日的场景,也可以用来调试数据库的一些奇怪场景,这样可以避免很多常见的数据库错误.
  - ### <p id="3_5">请求和连接</p>
    数据库会每一个 MongoDB 数据连接创建一个队列,存放这个连接的请求.
    注意,每个连接都有单独的队列,要是有两个 shell ,就有两个数据库连接.在一个 shell 中执行插入,另一个不一定能够看到,But,in the same shell,you can see the data changes made by the last connection. (_但是,在同一个 shell 中,你可以看到上次连接对数据的更改._)
    使用 Java 连接池的时候要特别注意这个事情,因为连接池和服务器建立了多个连接,并将请求分散到这些连接中,好在提供了一些机制来确保一系列的请求均由一个连接来处理.
